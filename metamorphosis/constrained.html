<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>demeter.metamorphosis.constrained API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>demeter.metamorphosis.constrained</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting"><code class="flex name class">
<span>class <span class="ident">ConstrainedMetamorphosis_Shooting</span></span>
<span>(</span><span>source, target, geodesic, cost_cst, data_term=None, optimizer_method='adadelta', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method for geodesic shooting optimisation. It needs to be provided with an object
inheriting from Geodesic_integrator</p>
<p>Important note to potential forks : all childs of this method
must have the same <strong>init</strong> method for proper loading.
:param source:
:param target:
:param geodesic:
:param cost_cst:
:param optimizer_method:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstrainedMetamorphosis_Shooting(Optimize_geodesicShooting):

    def __init__(self, source, target, geodesic, cost_cst,data_term=None, optimizer_method=&#39;adadelta&#39;,**kwargs):
        super().__init__(source, target, geodesic, cost_cst,data_term, optimizer_method)
        if self.mp.flag_O: self._cost_saving_ = self._oriented_cost_saving_


    def _get_mu_(self):
        return float(self.mp._get_mu_())

    def _get_rho_(self):
        return float(self.mp._get_rho_())

    def _get_gamma_(self):
        return float(self.mp._get_gamma_())

    def get_all_parameters(self):
        return {
            &#39;mu&#39;:self._get_mu_(),
            &#39;rho&#39;:self._get_rho_(),
            &#39;gamma&#39;:self._get_gamma_(),
            &#39;lambda&#39;:self.cost_cst,
            &#39;sigma_v&#39;:self.mp.sigma_v,
            &#39;n_step&#39;:self.mp.n_step,
            &#39;sharp&#39;:self.mp.flag_sharp,
        }

    # def _compute_V_norm_(self,*args):
    #     &#34;&#34;&#34;
    #
    #     usage 1: _compute_V_norm_(field)
    #         :field: torch Tensor of shape [1,H,W,2] or [1,D,H,W,3]
    #     usage 2: _compute_V_norm_(residual, image)
    #         :residual: torch Tensor of shape [1,C,H,W] or [1,C,D,H,W]
    #         :image: torch Tensor of shape [1,C,H,W] or [1,C,D,H,W]
    #     :return: float
    #     &#34;&#34;&#34;
    #
    #     # Computes only
    #     if len(args) == 2 and not args[0].shape[-1] in [2,3] :
    #         residual, image = args[0],args[1]
    #         C = residual.shape[1]
    #         grad_source = tb.spacialGradient(image)
    #         grad_source_resi = (grad_source * residual.unsqueeze(2)).sum(dim=1) / C
    #         K_grad_source_resi = self.mp.kernelOperator(grad_source_resi)
    #
    #         return (grad_source_resi * K_grad_source_resi).sum()
    #     elif len(args) == 1 and args[0].shape[-1] in [2,3]:
    #         print(&#34;\n Warning !!!!  make sure that kernelOrerator is self adjoint.&#34;)
    #         raise ValueError(&#34;This method to compute the V norm is wrong&#34;
    #                          &#34; with gaussian Kernels&#34;)
    #         field = args[0]
    #         k_field = self.mp.kernelOperator(field)
    #         return (k_field * field).sum()
    #     else:
    #         raise ValueError(f&#34;Bad arguments, see usage in Doc got args = {args}&#34;)


    def _oriented_cost_saving_(self, i, loss_stock):
        &#34;&#34;&#34; A variation of Optimize_geodesicShooting._default_cost_saving_

        :param i: index for saving the according values
                !!! if `loss_stock` is None, `loss_stock` will be initialized, and
                `i` must have the value of the number of iterations.
        :param loss_stock:
        :return: updated `loss_stock`
        &#34;&#34;&#34;
        # Initialise loss_stock
        if loss_stock is None:
            d = 4
            return torch.zeros((i, d))

        loss_stock[i, 0] = self.data_loss.detach()
        loss_stock[i, 1] = self.norm_v_2.detach()
        if self._get_mu_() != 0:
            loss_stock[i, 2] = self.norm_l2_on_z.detach()
        if self._get_gamma_() != 0:
            loss_stock[i, 3] = self.fields_diff_norm_V.detach()


        return loss_stock

    def get_total_cost(self):

        total_cost = self.to_analyse[1][:,0] + \
                    self.cost_cst * self.to_analyse[1][:,1]
        if self._get_mu_() != 0 :
            total_cost += self.cost_cst*(self._get_rho_())* self.to_analyse[1][:,2]
        if self.mp.flag_O:
            total_cost += self.cost_cst*(self._get_gamma_())*self.to_analyse[1][:,3]

        return total_cost

    def cost(self, residuals_ini: torch.Tensor) -&gt; torch.Tensor:

        lamb = self.cost_cst
        rho = self._get_rho_()

        self.mp.forward(self.source, residuals_ini, save=False, plot=0)

        # Compute the data_term. Default is the Ssd
        self.data_loss = self.data_term()

        # Norm V
        C = residuals_ini.shape[1]
        grad_source = tb.spacialGradient(self.source)
        grad_source_resi = (grad_source * residuals_ini.unsqueeze(2)).sum(dim=1) / C
        K_grad_source_resi = self.mp.kernelOperator(grad_source_resi)
        # print(f&#34;k_grad_source_resi = {K_grad_source_resi.shape}&#34;)
        if self.mp.flag_O:
            # print(f&#34;glag O  {(1 + self._get_gamma_() * self.mp.orienting_mask[0][None]).shape}&#34;)
            K_grad_source_resi *= (1 + self._get_gamma_() * self.mp.orienting_mask[0][None])
        self.norm_v_2 = (grad_source_resi * K_grad_source_resi).sum()
        # print(f&#34;norm_v_2 = {self.norm_v_2.shape}&#34;)

        self.total_cost = self.data_loss + lamb * self.norm_v_2

        # #  || v - w ||_V
        # if self.mp.flag_O:
        #     # print(&#34;différence de champs&#34;)
        #     fields_diff = grad_source_resi - tb.grid2im(self.mp.orienting_field[0][None])
        #     K_fields_diff = self.mp.kernelOperator(fields_diff)
        #     self.fields_diff_norm_V = (fields_diff * K_fields_diff).sum()/prod(self.source.shape[2:])
        #
        #     self.total_cost += lamb * self._get_gamma_() * self.fields_diff_norm_V

        # # Perform the scalar product of the field with orienting field
        if self.mp.flag_O:
            # print(&#34;produit scalaires&#34;)
            a = grad_source_resi * tb.grid2im(self.mp.orienting_field[0][None])
            a *= self._get_gamma_() * self.mp.orienting_mask[0][None]
            self.fields_diff_norm_V  =  (a).sum()/prod(self.source.shape[2:])
            # self.fields_diff_norm_V *=
            self.total_cost += - lamb * self._get_gamma_() * self.fields_diff_norm_V


        if self._get_mu_() != 0:
            # # Norm on the residuals only
            if self.mp.flag_W:
                self.norm_l2_on_z = (self.mp.rf.F(0) * residuals_ini ** 2).sum()/prod(self.source.shape[2:])
            else:
                self.norm_l2_on_z = (residuals_ini ** 2).sum()/prod(self.source.shape[2:])

            self.total_cost += lamb * rho * self.norm_l2_on_z

        # print(&#39;ssd :&#39;,self.ssd,&#39; norm_v :&#39;,self.norm_v_2)
        return self.total_cost


    def forward(self,
                z_0,
                n_iter=10,
                grad_coef=1e-3,
                verbose=True,
                plot=False,
                sharp=None
                ):
        if self.mp.flag_W:
            self.mp.rf.to_device(z_0.device)
        if self.mp.flag_O:
            self.mp.orienting_mask = self.mp.orienting_mask.to(z_0.device)
            self.mp.orienting_field = self.mp.orienting_field.to(z_0.device)
        super(ConstrainedMetamorphosis_Shooting, self).forward(z_0, n_iter, grad_coef, verbose,plot)
        self.to_device(&#39;cpu&#39;)

    def to_device(self, device):
        if self.mp.flag_W:
            self.mp.rf.to_device(device)
        if self.mp.flag_O:
            self.mp.orienting_mask = self.mp.orienting_mask.to(device)
            self.mp.orienting_field = self.mp.orienting_field.to(device)
        super(ConstrainedMetamorphosis_Shooting, self).to_device(device)

    def plot_cost(self):
        fig1, ax1 = plt.subplots(1, 2,figsize=(10,10))

        cost_stock = self.to_analyse[1].detach().numpy()

        ssd_plot = cost_stock[:, 0]
        ax1[0].plot(ssd_plot, &#34;--&#34;, color=&#39;blue&#39;, label=&#39;ssd&#39;)
        ax1[1].plot(ssd_plot, &#34;--&#34;, color=&#39;blue&#39;, label=&#39;ssd&#39;)

        normv_plot = self.cost_cst * cost_stock[:, 1]
        ax1[0].plot(normv_plot, &#34;--&#34;, color=&#39;green&#39;, label=&#39;normv&#39;)
        ax1[1].plot(cost_stock[:, 1], &#34;--&#34;, color=&#39;green&#39;, label=&#39;normv&#39;)
        total_cost = ssd_plot + normv_plot
        if self._get_mu_() != 0:
            norm_l2_on_z = self.cost_cst * (self._get_rho_()) * cost_stock[:, 2]
            total_cost += norm_l2_on_z
            ax1[0].plot(norm_l2_on_z, &#34;--&#34;, color=&#39;orange&#39;, label=&#39;norm_l2_on_z&#39;)
            ax1[1].plot(cost_stock[:, 2], &#34;--&#34;, color=&#39;orange&#39;, label=&#39;norm_l2_on_z&#39;)

        if self._get_gamma_() != 0:
            fields_diff_norm_v = self.cost_cst * self._get_gamma_() * cost_stock[:, 3]
            total_cost += fields_diff_norm_v
            ax1[0].plot(fields_diff_norm_v, &#34;--&#34;, color=&#34;purple&#34;, label=&#39;fields_diff_norm_v&#39;)
            ax1[1].plot(cost_stock[:, 3], &#34;--&#34;, color=&#39;purple&#39;, label=&#39;fields_diff_norm_v&#39;)

        ax1[0].plot(total_cost, color=&#39;black&#39;, label=r&#39;\Sigma&#39;)
        ax1[0].legend()
        ax1[1].legend()
        ax1[0].set_title(&#34;Lambda = &#34; + str(self.cost_cst) +
                         &#34; mu = &#34; + str(self._get_mu_()) +
                         &#34; rho = &#34; + str(self._get_rho_()) +
                         &#34;gamma = &#34; + str(self._get_gamma_()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting">Optimize_geodesicShooting</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.cost"><code class="name flex">
<span>def <span class="ident">cost</span></span>(<span>self, residuals_ini: torch.Tensor) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, z_0, n_iter=10, grad_coef=0.001, verbose=True, plot=False, sharp=None) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_all_parameters"><code class="name flex">
<span>def <span class="ident">get_all_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_total_cost"><code class="name flex">
<span>def <span class="ident">get_total_cost</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.to_device"><code class="name flex">
<span>def <span class="ident">to_device</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting">Optimize_geodesicShooting</a></b></code>:
<ul class="hlist">
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.compute_DICE" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.compute_DICE">compute_DICE</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.forward_safe_mode" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.forward_safe_mode">forward_safe_mode</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_cost" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_cost">plot_cost</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_imgCmp" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_imgCmp">plot_imgCmp</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.save" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator"><code class="flex name class">
<span>class <span class="ident">ConstrainedMetamorphosis_integrator</span></span>
<span>(</span><span>residual_function: <a title="demeter.metamorphosis.constrained.Residual_norm_function" href="#demeter.metamorphosis.constrained.Residual_norm_function">Residual_norm_function</a> = None, orienting_field: torch.Tensor = None, orienting_mask: torch.Tensor = None, mu=0, rho=0, gamma=0, sigma_v=(1, 1, 1), n_step=None, border_effect=True, sharp=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for defining the way of integrating over geodesics</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstrainedMetamorphosis_integrator(Geodesic_integrator):

    def __init__(self, residual_function: Residual_norm_function = None,
                 orienting_field: torch.Tensor = None,
                 orienting_mask: torch.Tensor = None,
                 mu=0,
                 rho=0,
                 gamma=0,
                 sigma_v=(1, 1, 1),
                 n_step=None,
                 border_effect=True,
                 sharp = False,
                 **kwargs
    ):
        super(ConstrainedMetamorphosis_integrator, self).__init__(sigma_v)
        if residual_function is None:
            self.flag_W, self.mu, self.rho = False, mu, rho
            print(&#34;not Weighted&#34;)
        else:
            print(n_step)
            if not n_step is None:
                if hasattr(residual_function, &#39;n_step&#39;) and \
                        (residual_function.n_step != n_step):
                    raise ValueError(f&#34;{residual_function.__class__.__name__}.n_step is {residual_function.n_step}&#34;
                                     f&#34;and {self.__class__.__name__} = {n_step}. They must be equal.&#34;)
            print(&#34;Weighted&#34;)
            self.rf = residual_function
            try:
                self.rf.set_geodesic_integrator(self)
            except AttributeError:
                pass
            self.flag_W = True
        if gamma == 0 or orienting_field is None:
            print(&#34;not oriented&#34;)
            self.gamma, self.orienting_mask, self.orienting_field = 0, None, None
            self.flag_O = False
            if self.flag_W : self.n_step = self.rf.n_step
        else:
            print(&#34;oriented&#34;)
            self.flag_O = True
            self.orienting_mask = orienting_mask
            self.orienting_field = orienting_field
            self.gamma = gamma
            self.n_step = orienting_field.shape[0]

        if self.flag_O and self.flag_W:
            if orienting_field.shape[0] != self.rf.n_step or\
                    orienting_mask.shape[0] != self.rf.n_step:
                raise ValueError(f&#34;orienting_field, orienting_mask and the mask of the residual_function&#34;
                                 f&#34;must have same size got (resp.):{orienting_field.shape} &#34;
                                 f&#34;,{orienting_mask.shape},{self.rf.mask.shape}&#34;
                                 )

        self._init_sharp_(sharp)

        # self.n_step = n_step
        self.rf = residual_function



    def __repr__(self):
        if self.flag_W and self.flag_O:
            mode = &#39;Weighted &amp; Oriented&#39;
        elif self.flag_W:
            mode = &#39;weighted&#39;
        elif self.flag_O:
            mode = &#39;oriented&#39;
        else:
            mode = &#39;why are you using this class ?&#39;

        if self.flag_W:
            param = self.rf.__repr__()
        else:
            param = f&#34;parameters :(mu = {self._get_mu_():.2E},rho = {self._get_rho_():.2E}&#34;
        if self.flag_O: param += f&#34;gamma = {self._get_gamma_():.2E}&#34;
        param += &#34;)&#34;

        return self.__class__.__name__ + f&#34;({mode})\n&#34; \
                                         f&#34;\t {param}\n\t{self.kernelOperator.__repr__()} &#34;

    def _get_mu_(self):
        if self.flag_W:
            return self.rf.mu
        else:
            return self.mu

    def _get_rho_(self):
        if self.flag_W:
            return float(self.rf.rho)
        else:
            return float(self.rho)

    def _get_gamma_(self):
        if self.flag_O:
            return self.gamma
        else:
            return 0


    # def _update_residuals_weighted_semiLagrangian_(self, deformation):
    #     f_t = self.rf.f(self._i)
    #     fz_times_div_v = f_t * self.residuals * tb.Field_divergence(dx_convention=&#39;pixel&#39;)(self.field)[0, 0]
    #     div_fzv = -tb.imgDeform(f_t * self.residuals,
    #                             deformation,
    #                             dx_convention=&#39;pixel&#39;,
    #                             clamp=False)[0, 0] \
    #               + fz_times_div_v / self.n_step
    #     z_time_dtF = self.residuals * self.rf.dt_F(self._i)
    #     self.residuals = - (div_fzv + z_time_dtF) / f_t
    #
    # def _update_image_weighted_semiLagrangian_(self, deformation,residuals = None,sharp=False):
    #     if residuals is None: residuals = self.residuals
    #     image = self.source if sharp else self.image
    #     self.image = tb.imgDeform(image, deformation, dx_convention=&#39;pixel&#39;) + \
    #                  (self.rf.F_div_f(self._i) *  residuals) / self.n_step
    #                  # (self.rf.mu * self.rf.mask[self._i] * residuals) / self.n_step
    #
    #     # ga = (self.rf.mask[self._i] * self.residuals) / self.n_step
    #     # plt.figure()
    #     # p = plt.imshow(ga[0])
    #     # plt.colorbar(p)
    #     # plt.show()
    #
    # def _update_field_oriented_weighted_(self):
    #     grad_image = tb.spacialGradient(self.image, dx_convention=&#39;pixel&#39;)
    #     if self.flag_W:
    #         free_field = tb.im2grid(
    #             self.kernelOperator((- self.rf.f(self._i) * self.residuals * grad_image[0]))
    #         )/self._get_mu_()
    #     else:
    #         free_field = self._compute_vectorField_(self.residuals, grad_image)
    #         free_field *= self._field_cst_mult()
    #     oriented_field = 0
    #     if self.flag_O:
    #         mask_i = self.orienting_mask[self._i][..., None].clone()
    #         free_field *= 1 / (1 + (self.gamma * mask_i))
    #
    #         oriented_field = self.orienting_field[self._i][None].clone()
    #         oriented_field *= (self.gamma * mask_i) / (1 + (self.gamma * mask_i))
    #
    #     self.field = free_field + oriented_field

    def step(self):
        if self.flag_O or self.flag_W:
            self._update_field_oriented_weighted_()
        else:
            self._update_field_()

        if self.flag_sharp:
            self._update_sharp_intermediary_field_()
            def_z = self._phis[self._i][self._i]
            def_I = self._phis[self._i][0]
            if self._get_mu_() != 0:
                resi_to_add = self._compute_sharp_intermediary_residuals_()
                # resi_to_add = self.kernelOperator(self._compute_sharp_intermediary_residuals_())
            if self._i &gt; 0: self._phis[self._i - 1] = None
        else:
            def_z = self.id_grid - self.field / self.n_step
            def_I = def_z
            resi_to_add = self.momentum

        if self.flag_W:
            self._update_image_weighted_semiLagrangian_(def_I,resi_to_add,sharp=self.flag_sharp)
            self._update_momentum_weighted_semiLagrangian_(def_z)

            # DEBUG
            # print(&#34;&gt;&gt; &#34;,self._i)
            # if v_scalar_n.sum()&gt; 0:# and self._i in [0,3,8,15]:
            #     fig,ax = plt.subplots(2,2)
            #     # tb.quiver_plot(self.rf.border_normal_vector(self._i).cpu(),ax=ax[0],step= 5)
            #     _1_= ax[0,0].imshow(self.residuals.detach().cpu())
            #     fig.colorbar(_1_,ax=ax[0,0],fraction=0.046, pad=0.04)
            #     ax[0,0].set_title(&#39;z&#39;)
            #     _2_ = ax[0,1].imshow((self.rf.inv_F(self._i)*(div_fzv)).cpu().detach())
            #     fig.colorbar(_2_,ax=ax[0,1],fraction=0.046, pad=0.04)
            #     ax[0,1].set_title(&#39;div_fzv&#39;)
            #     _3_ = ax[1,0].imshow((( z_time_dtF)).cpu().detach())
            #     fig.colorbar(_3_,ax=ax[1,0],fraction=0.046, pad=0.04)
            #     ax[1,0].set_title(&#39;z x dtF&#39;)
            #     _4_ = ax[1,1].imshow((border).cpu().detach())
            #     fig.colorbar(_4_,ax=ax[1,1],fraction=0.046, pad=0.04)
            #     ax[1,1].set_title(&#39;border&#39;)
            #     plt.show()
            # else:
            #     print(&#34;-------------ZERO------------------&#34;)
            # print(self._i,&#39; : &#39;,border.mean()/div_fzv.mean(), z_time_dtF.mean()/div_fzv.mean())

        else:
            self._update_image_semiLagrangian_(def_I,resi_to_add,
                                               sharp = self.flag_sharp)
            self._update_residuals_semiLagrangian_(def_z)

        return (self.image, self.field, self.momentum)

    def compute_field_sim(self):
        if not self.flag_O:
            print(&#34;Field similarity do not apply here flag_O = &#34;,self.flag_O)
            return torch.inf
        N_time_HW = self.orienting_field.shape[0]*prod(self.orienting_field.shape[2:])
        return (self.field_stock - self.orienting_field).abs().sum()/N_time_HW

    def plot_field_sim(self):
        if self.flag_O:
            diff = self.field_stock - self.orienting_field
            diff = (diff.abs().sum(axis=-1)*self.orienting_mask[:,0]).sum(axis=0)
            print(diff.shape)
            fig,ax = plt.subplots()
            p = ax.imshow(diff,origin=&#39;lower&#39;)
            fig.colorbar(p,ax=ax,fraction=0.046, pad=0.04)
        else:
            print(&#34;Not oriented ! No field_sim plot !&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.abstract.Geodesic_integrator" href="abstract.html#demeter.metamorphosis.abstract.Geodesic_integrator">Geodesic_integrator</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.compute_field_sim"><code class="name flex">
<span>def <span class="ident">compute_field_sim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.plot_field_sim"><code class="name flex">
<span>def <span class="ident">plot_field_sim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="demeter.metamorphosis.abstract.Geodesic_integrator" href="abstract.html#demeter.metamorphosis.abstract.Geodesic_integrator">Geodesic_integrator</a></b></code>:
<ul class="hlist">
<li><code><a title="demeter.metamorphosis.abstract.Geodesic_integrator.forward" href="abstract.html#demeter.metamorphosis.abstract.Geodesic_integrator.forward">forward</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Geodesic_integrator.get_deformation" href="abstract.html#demeter.metamorphosis.abstract.Geodesic_integrator.get_deformation">get_deformation</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Geodesic_integrator.get_deformator" href="abstract.html#demeter.metamorphosis.abstract.Geodesic_integrator.get_deformator">get_deformator</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="demeter.metamorphosis.constrained.Reduce_field_Optim"><code class="flex name class">
<span>class <span class="ident">Reduce_field_Optim</span></span>
<span>(</span><span>source, target, geodesic, cost_cst, optimizer_method, mask_reduce, gamma)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method for geodesic shooting optimisation. It needs to be provided with an object
inheriting from Geodesic_integrator</p>
<p>Important note to potential forks : all childs of this method
must have the same <strong>init</strong> method for proper loading.
:param source:
:param target:
:param geodesic:
:param cost_cst:
:param optimizer_method:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reduce_field_Optim(Optimize_geodesicShooting):

    def __init__(self,source, target, geodesic, cost_cst, optimizer_method,mask_reduce,gamma):
        super().__init__(source, target, geodesic, cost_cst, optimizer_method)
        self._cost_saving_ = self._reduce_cost_saving_
        self.gamma = gamma
        self.mask_reduce = mask_reduce
        if self.mp.flag_O:
            raise ValueError(&#34;Geodesic integrator was set incorrectly. Reduce field&#34;
                             &#34;should not be used with an oriented framework. mr.glag_O is True.&#34;)

    def _get_mu_(self):
        return float(self.mp._get_mu_())

    def _get_rho_(self):
        return float(self.mp._get_rho_())

    def _get_gamma_(self):
        return float(self.gamma)

    def _reduce_cost_saving_(self, i, loss_stock):
        &#34;&#34;&#34; A variation of Optimize_geodesicShooting._default_cost_saving_

        :param i: index for saving the according values
                !!! if `loss_stock` is None, `loss_stock` will be initialized, and
                `i` must have the value of the number of iterations.
        :param loss_stock:
        :return: updated `loss_stock`
        &#34;&#34;&#34;
        # Initialise loss_stock
        if loss_stock is None:
            d = 4
            return torch.zeros((i, d))

        loss_stock[i, 0] = self.ssd.detach()
        loss_stock[i, 1] = self.norm_v_2.detach()
        loss_stock[i,3] = self.norm_l2_on_mask1.detach()
        if self._get_mu_() != 0:
            loss_stock[i, 2] = self.norm_l2_on_z.detach()


        return loss_stock

    def get_total_cost(self):
        return super().get_total_cost() + self.cost_cst * self._get_gamma_() * self.to_analyse[1][:,3]

    def cost(self, residuals_ini: torch.Tensor) -&gt; torch.Tensor:

        lamb = self.cost_cst
        rho = self._get_rho_()

        self.mp.forward(self.source, residuals_ini, save=True, plot=0)
        # checkpoint(self.mp.forward,self.source.clone(),self.id_grid,residuals_ini)
        # self.ssd = .5*((self.target - self.mp.image)**2).sum()
        self.ssd = cf.SumSquaredDifference(self.target)(self.mp.image)

        # Norm V
        C = residuals_ini.shape[1]
        grad_source = tb.spacialGradient(self.source)
        grad_source_resi = (grad_source * residuals_ini.unsqueeze(2)).sum(dim=1) / C
        K_grad_source_resi = self.mp.kernelOperator(grad_source_resi)
        self.norm_v_2 = (grad_source_resi * K_grad_source_resi).sum()

        self.total_cost = self.ssd + lamb * self.norm_v_2

        # Reduce field norm
        mask_1 = tb.imgDeform(self.mask_reduce[0][None].cpu(),self.mp.get_deformator(),dx_convention=&#39;pixel&#39;)
        self.norm_l2_on_mask1 = (mask_1**2).sum()/prod(self.source.shape[2:])

        self.total_cost += lamb * self._get_gamma_() *self.norm_l2_on_mask1

        if self._get_mu_() != 0:
            # # Norm on the residuals only
            if self.mp.flag_W:
                self.norm_l2_on_z = (self.mp.rf.F(0) * residuals_ini ** 2).sum()/prod(self.source.shape[2:])
            else:
                self.norm_l2_on_z = (residuals_ini ** 2).sum()/prod(self.source.shape[2:])

            self.total_cost += lamb * rho * self.norm_l2_on_z

        # print(&#39;ssd :&#39;,self.ssd,&#39; norm_v :&#39;,self.norm_v_2)
        return self.total_cost

    def forward(self,
                z_0,
                n_iter=10,
                grad_coef=1e-3,
                verbose=True,
                sharp=None
                ):
        if self.mp.flag_W:
            self.mp.rf.to_device(z_0.device)
        self.mask_reduce.to(z_0.device)
        super(Reduce_field_Optim, self).forward(z_0, n_iter, grad_coef, verbose)
        self.to_device(&#39;cpu&#39;)

    def to_device(self, device):
        if self.mp.flag_W:
            self.mp.rf.to_device(device)
        self.mask_reduce.to(device)
        super(Reduce_field_Optim, self).to_device(device)

    def plot_cost(self):
        plt.rcParams[&#39;figure.figsize&#39;] = [10, 10]
        fig1, ax1 = plt.subplots(1, 2)

        cost_stock = self.to_analyse[1].detach().numpy()

        ssd_plot = cost_stock[:, 0]
        ax1[0].plot(ssd_plot, &#34;--&#34;, color=&#39;blue&#39;, label=&#39;ssd&#39;)
        ax1[1].plot(ssd_plot, &#34;--&#34;, color=&#39;blue&#39;, label=&#39;ssd&#39;)

        normv_plot = self.cost_cst * cost_stock[:, 1]
        ax1[0].plot(normv_plot, &#34;--&#34;, color=&#39;green&#39;, label=&#39;normv&#39;)
        ax1[1].plot(cost_stock[:, 1], &#34;--&#34;, color=&#39;green&#39;, label=&#39;normv&#39;)
        total_cost = ssd_plot + normv_plot
        if self._get_mu_() != 0:
            norm_l2_on_z = self.cost_cst * (self._get_rho_()) * cost_stock[:, 2]
            total_cost += norm_l2_on_z
            ax1[0].plot(norm_l2_on_z, &#34;--&#34;, color=&#39;orange&#39;, label=&#39;norm_l2_on_z&#39;)
            ax1[1].plot(cost_stock[:, 2], &#34;--&#34;, color=&#39;orange&#39;, label=&#39;norm_l2_on_z&#39;)

        if self._get_gamma_() != 0:
            reduce_field_norm = self.cost_cst * self._get_gamma_() * cost_stock[:, 3]
            total_cost += reduce_field_norm
            ax1[0].plot(reduce_field_norm, &#34;--&#34;, color=&#34;purple&#34;, label=&#39;reduce_field_norm_2&#39;)
            ax1[1].plot(cost_stock[:, 3], &#34;--&#34;, color=&#39;purple&#39;, label=&#39;reduce_field_norm_2&#39;)

        ax1[0].plot(total_cost, color=&#39;black&#39;, label=r&#39;\Sigma&#39;)
        ax1[0].legend()
        ax1[1].legend()
        ax1[0].set_title(&#34;Lambda = &#34; + str(self.cost_cst) +
                         &#34; mu = &#34; + str(self._get_mu_()) +
                         &#34; rho = &#34; + str(self._get_rho_()) +
                         &#34;gamma = &#34; + str(self._get_mu_()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting">Optimize_geodesicShooting</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.Reduce_field_Optim.cost"><code class="name flex">
<span>def <span class="ident">cost</span></span>(<span>self, residuals_ini: torch.Tensor) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Reduce_field_Optim.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, z_0, n_iter=10, grad_coef=0.001, verbose=True, sharp=None) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Reduce_field_Optim.get_total_cost"><code class="name flex">
<span>def <span class="ident">get_total_cost</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Reduce_field_Optim.to_device"><code class="name flex">
<span>def <span class="ident">to_device</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting">Optimize_geodesicShooting</a></b></code>:
<ul class="hlist">
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.compute_DICE" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.compute_DICE">compute_DICE</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.forward_safe_mode" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.forward_safe_mode">forward_safe_mode</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_cost" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_cost">plot_cost</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_imgCmp" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.plot_imgCmp">plot_imgCmp</a></code></li>
<li><code><a title="demeter.metamorphosis.abstract.Optimize_geodesicShooting.save" href="abstract.html#demeter.metamorphosis.abstract.Optimize_geodesicShooting.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost"><code class="flex name class">
<span>class <span class="ident">Residual_norm_borderBoost</span></span>
<span>(</span><span>mask, mu, rho)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Residual_norm_borderBoost(Residual_norm_function):

    def __init__(self,mask,mu,rho):
        raise NotImplementedError(&#34;Need to redo all of this ....&#34;)
        if rho &lt; 0:
            raise ValueError(f&#34;rho must be a real positive value got rho = {rho:.3f}&#34;)
        super().__init__(mask, mu,rho)
        n_step = mask.shape[0]

        # Preparation of the time derivative F(M_t)
        grad_mask = tb.spacialGradient(self.seg_tumour)
        self.grad_mask_norm = (grad_mask**2).sum(dim = 2).sqrt()
        # TODO : make sure that this n_step is the same that the geodesic integrator will use
        grad_dt_mask = tb.spacialGradient((self.seg_tumour[1:] - self.seg_tumour[:-1]) / n_step)
        grad_mask_times_grad_dt_mask = (grad_mask[1:] * grad_dt_mask).sum(dim=2)
        self.dt_F_mask = torch.nan_to_num(grad_mask_times_grad_dt_mask / self.grad_mask_norm[1:])

    def __repr__(self):
        return f&#39;{self.__class__.__name__}:(mu = {self.mu:.2E},rho = {self.rho:.2E})&#39; \
               f&#39; rho/mu = {self.rho/self.mu}, mu/rho = {self.mu/self.rho}.&#39;

    def cpu(self):
        self.grad_mask_norm = self.grad_mask_norm.to(&#39;cpu&#39;)
        self.dt_F_mask = self.dt_F_mask.to(&#39;cpu&#39;)
        super(Residual_norm_borderBoost, self).cpu()

    def to_device(self,device):
        self.grad_mask_norm = self.grad_mask_norm.to(device)
        self.dt_F_mask = self.dt_F_mask.to(device)
        super(Residual_norm_borderBoost, self).to_device(device)

    def f(self,t):
        return self.mask[t,0]*(1 + self.rho * self.grad_mask_norm[t,0])

    def F(self,t):
        return (self.mu +  self.rho * self.grad_mask_norm[t,0])/self.mu

    def dt_F(self,t):
        try:
            return self.dt_F_mask[t,0]
        except:
            return 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.constrained.Residual_norm_function" href="#demeter.metamorphosis.constrained.Residual_norm_function">Residual_norm_function</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost.F"><code class="name flex">
<span>def <span class="ident">F</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost.cpu"><code class="name flex">
<span>def <span class="ident">cpu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost.dt_F"><code class="name flex">
<span>def <span class="ident">dt_F</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_borderBoost.to_device"><code class="name flex">
<span>def <span class="ident">to_device</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function"><code class="flex name class">
<span>class <span class="ident">Residual_norm_function</span></span>
<span>(</span><span>mask, mu=1, rho=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Residual_norm_function(ABC):

    @abstractmethod
    def __init__(self,mask,mu = 1,rho=None):
        if mu &lt;= 0:
            raise ValueError(f&#34;mu must be a non zero real positive value, got mu = {mu:.3f}&#34;)
        self.mu = mu
        self.rho = mu if rho is None else rho
        self.mask = mask
        if self.mask.shape[0] &gt; 1: self.n_step = self.mask.shape[0]

    def __repr__(self):
        return f&#39;{self.__class__.__name__}:(mu = {self.mu:.2E},rho = {self.rho:.2E})&#39;

    def to_device(self,device):
        self.mask = self.mask.to(device)

    @abstractmethod
    def f(self,t):
        pass

    def F(self,t):
        return self.mask[t] * self.f(t) / self.mu

    def F_div_f(self,t):
        return self.mu*self.mask[t]

    @abstractmethod
    def dt_F(self,t):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost">Residual_norm_borderBoost</a></li>
<li><a title="demeter.metamorphosis.constrained.Residual_norm_identity" href="#demeter.metamorphosis.constrained.Residual_norm_identity">Residual_norm_identity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function.F"><code class="name flex">
<span>def <span class="ident">F</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function.F_div_f"><code class="name flex">
<span>def <span class="ident">F_div_f</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function.dt_F"><code class="name flex">
<span>def <span class="ident">dt_F</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_function.to_device"><code class="name flex">
<span>def <span class="ident">to_device</span></span>(<span>self, device)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_identity"><code class="flex name class">
<span>class <span class="ident">Residual_norm_identity</span></span>
<span>(</span><span>mask, mu, rho)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Residual_norm_identity(Residual_norm_function):

    def __init__(self,mask,mu,rho):
        if rho &lt; 0:
            raise ValueError(f&#34;rho must be a real positive value got rho = {rho:.3f}&#34;)
        super(Residual_norm_identity, self).__init__(mask, mu,rho)


    def __repr__(self):
        return f&#39;{self.__class__.__name__}:(mu = {self.mu:.2E},rho = {self.rho:.2E})&#39; \
               f&#39;F = rho/mu = {self.rho/self.mu}, f = rho).&#39;

    def f(self,t):
        return self.rho

    def dt_F(self,t):
        return 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demeter.metamorphosis.constrained.Residual_norm_function" href="#demeter.metamorphosis.constrained.Residual_norm_function">Residual_norm_function</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.metamorphosis.constrained.Residual_norm_identity.dt_F"><code class="name flex">
<span>def <span class="ident">dt_F</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.metamorphosis.constrained.Residual_norm_identity.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="demeter.metamorphosis" href="index.html">demeter.metamorphosis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting">ConstrainedMetamorphosis_Shooting</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.cost" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.cost">cost</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.forward" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.forward">forward</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_all_parameters" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_all_parameters">get_all_parameters</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_total_cost" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.get_total_cost">get_total_cost</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.to_device" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_Shooting.to_device">to_device</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator">ConstrainedMetamorphosis_integrator</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.compute_field_sim" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.compute_field_sim">compute_field_sim</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.plot_field_sim" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.plot_field_sim">plot_field_sim</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.step" href="#demeter.metamorphosis.constrained.ConstrainedMetamorphosis_integrator.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.Reduce_field_Optim" href="#demeter.metamorphosis.constrained.Reduce_field_Optim">Reduce_field_Optim</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.Reduce_field_Optim.cost" href="#demeter.metamorphosis.constrained.Reduce_field_Optim.cost">cost</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Reduce_field_Optim.forward" href="#demeter.metamorphosis.constrained.Reduce_field_Optim.forward">forward</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Reduce_field_Optim.get_total_cost" href="#demeter.metamorphosis.constrained.Reduce_field_Optim.get_total_cost">get_total_cost</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Reduce_field_Optim.to_device" href="#demeter.metamorphosis.constrained.Reduce_field_Optim.to_device">to_device</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost">Residual_norm_borderBoost</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost.F" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost.F">F</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost.cpu" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost.cpu">cpu</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost.dt_F" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost.dt_F">dt_F</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost.f" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost.f">f</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_borderBoost.to_device" href="#demeter.metamorphosis.constrained.Residual_norm_borderBoost.to_device">to_device</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.Residual_norm_function" href="#demeter.metamorphosis.constrained.Residual_norm_function">Residual_norm_function</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_function.F" href="#demeter.metamorphosis.constrained.Residual_norm_function.F">F</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_function.F_div_f" href="#demeter.metamorphosis.constrained.Residual_norm_function.F_div_f">F_div_f</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_function.dt_F" href="#demeter.metamorphosis.constrained.Residual_norm_function.dt_F">dt_F</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_function.f" href="#demeter.metamorphosis.constrained.Residual_norm_function.f">f</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_function.to_device" href="#demeter.metamorphosis.constrained.Residual_norm_function.to_device">to_device</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.metamorphosis.constrained.Residual_norm_identity" href="#demeter.metamorphosis.constrained.Residual_norm_identity">Residual_norm_identity</a></code></h4>
<ul class="">
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_identity.dt_F" href="#demeter.metamorphosis.constrained.Residual_norm_identity.dt_F">dt_F</a></code></li>
<li><code><a title="demeter.metamorphosis.constrained.Residual_norm_identity.f" href="#demeter.metamorphosis.constrained.Residual_norm_identity.f">f</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
