<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>demeter.utils.torchbox API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>demeter.utils.torchbox</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="demeter.utils.torchbox.BCH"><code class="name flex">
<span>def <span class="ident">BCH</span></span>(<span>v, w, order=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the Backer-Campbell-Hausdorff formula</p></div>
</dd>
<dt id="demeter.utils.torchbox.addGrid2im"><code class="name flex">
<span>def <span class="ident">addGrid2im</span></span>(<span>img, n_line, cst=0.1, method='dots')</span>
</code></dt>
<dd>
<div class="desc"><p>:param img:
:param n_line:
:param cst:
:param method:
:return:</p></div>
</dd>
<dt id="demeter.utils.torchbox.checkDiffeo"><code class="name flex">
<span>def <span class="ident">checkDiffeo</span></span>(<span>field)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.compose_fields"><code class="name flex">
<span>def <span class="ident">compose_fields</span></span>(<span>field, grid_on, dx_convention='2square')</span>
</code></dt>
<dd>
<div class="desc"><p>compose a field on a deformed grid</p></div>
</dd>
<dt id="demeter.utils.torchbox.create_meshgrid3d"><code class="name flex">
<span>def <span class="ident">create_meshgrid3d</span></span>(<span>depth: int, height: int, width: int, normalized_coordinates: bool = True, device=device(type='cpu'), dtype: torch.dtype = torch.float32) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a coordinate grid for an image.</p>
<p>When the flag <code>normalized_coordinates</code> is set to True, the grid is
normalized to be in the range :math:<code>[-1,1]</code> to be consistent with the pytorch
function :py:func:<code>torch.nn.functional.grid_sample</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depth</code></strong></dt>
<dd>the image depth (channels).</dd>
<dt><strong><code>height</code></strong></dt>
<dd>the image height (rows).</dd>
<dt><strong><code>width</code></strong></dt>
<dd>the image width (cols).</dd>
<dt><strong><code>normalized_coordinates</code></strong></dt>
<dd>whether to normalize
coordinates in the range :math:<code>[-1,1]</code> in order to be consistent with the
PyTorch function :py:func:<code>torch.nn.functional.grid_sample</code>.</dd>
<dt><strong><code>device</code></strong></dt>
<dd>the device on which the grid will be generated.</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>the data type of the generated grid.</dd>
</dl>
<h2 id="return">Return</h2>
<p>grid tensor with shape :math:<code>(1, D, H, W, 3)</code>.</p></div>
</dd>
<dt id="demeter.utils.torchbox.deformation_show"><code class="name flex">
<span>def <span class="ident">deformation_show</span></span>(<span>deformation, step=2, check_diffeo=False, title='', color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>:param deformation:
:param step:
:param check_diffeo:
:return:</p>
<p>Example :
cms = mbs.getCMS_allcombinaision()</p>
<p>H,W = 100,150</p>
<h1 id="vector-defomation-generation">vector defomation generation</h1>
<p>v = mbs.field2D_bspline(cms,(H,W),dim_stack=2).unsqueeze(0)
v *= 0.5</p>
<p>deform_diff = vff.FieldIntegrator(method='fast_exp')(v.clone(),forward= True)</p>
<p>deformation_show(deform_diff,step=4,check_diffeo=True)</p></div>
</dd>
<dt id="demeter.utils.torchbox.detOfJacobian"><code class="name flex">
<span>def <span class="ident">detOfJacobian</span></span>(<span>jaco)</span>
</code></dt>
<dd>
<div class="desc"><p>compute the determinant of the jacobian from field_2d_jacobian</p>
<p>:param jaco: B,2,2,H,W tensor
B,3,3,D,H,W tensor
:return: B,H,W tensor</p></div>
</dd>
<dt id="demeter.utils.torchbox.field2diffeo"><code class="name flex">
<span>def <span class="ident">field2diffeo</span></span>(<span>in_vectField, N=None, save=False, forward=True)</span>
</code></dt>
<dd>
<div class="desc"><p>function deprecated; see vector_field_to_flow</p></div>
</dd>
<dt id="demeter.utils.torchbox.fieldNorm2"><code class="name flex">
<span>def <span class="ident">fieldNorm2</span></span>(<span>field)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.field_2d_hessian"><code class="name flex">
<span>def <span class="ident">field_2d_hessian</span></span>(<span>field_grad)</span>
</code></dt>
<dd>
<div class="desc"><p>compute the hessian of a field from the jacobian</p>
<p>:param field_grad: BxnxpxHxW tensor n = p = 2
:return: Bx8x2xHxW tensor</p>
<p>:example :</p>
<p>hess = field_2d_hessian(I_g)
print('hess.shape = '+str(hess.shape))
fig, axes = plt.subplots(2,4)
for x in range(2):
for d in range(4):
axes[x][d].imshow(hess[0,d,x,:,:].detach().numpy(),cmap='gray')
axes[x][d].set_title(str((x,d)))
plt.show()</p></div>
</dd>
<dt id="demeter.utils.torchbox.field_2d_jacobian"><code class="name flex">
<span>def <span class="ident">field_2d_jacobian</span></span>(<span>field)</span>
</code></dt>
<dd>
<div class="desc"><p>:param field: field.size (B,H,W,2)
:return: output.size = (B,2,2,H,W)</p>
<p>:example:
field = torch.zeros((100,100,2))
field[::2,:,0] = 1
field[:,::2,1] = 1</p>
<p>jaco =
field_2d_jacobian(field)</p>
<p>plt.rc('text',usetex=True)
fig, axes = plt.subplots(2,2)
axes[0,0].imshow(jaco[0,0,0,:,:].detach().numpy(),cmap='gray')
axes[0,0].set_title(r"$\frac{\partial f_1}{\partial x}$")
axes[0,1].imshow(jaco[0,0,1,:,:].detach().numpy(),cmap='gray')
axes[0,1].set_title(r"$\frac{\partial f_1}{\partial y}$")
axes[1,0].imshow(jaco[0,1,0,:,:].detach().numpy(),cmap='gray')
axes[1,0].set_title(r"$\frac{\partial f_2}{\partial x}$")
axes[1,1].imshow(jaco[0,1,1,:,:].detach().numpy(),cmap='gray')
axes[1,1].set_title(r"$\frac{\partial f_2}{\partial y}$")</p>
<p>plt.show()</p></div>
</dd>
<dt id="demeter.utils.torchbox.field_divergence"><code class="name flex">
<span>def <span class="ident">field_divergence</span></span>(<span>field, dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>make the divergence of a field, for each pixel $p$ in I
$$div(I(p)) = \sum_{i=1}^C \frac{\partial I(p)_i}{\partial x_i}$$
:param field: (B,H,W,2) tensor
:return:</p>
<p>cms = torch.tensor([
# control matrices
[[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, -1, 0, -1, 0, -1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, -1, 0, +1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, +1, 0, -1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, -1, 0, -1, 0, -1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
],
[[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, +1, 0, -1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],#[0, .2, .75, 1, 0],
[0, -1, 0, -1, 0, -1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, -1, 0, -1, 0, -1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, +1, 0, -1, 0, +1, 0, +1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0]]
],requires_grad=False,dtype=torch.float)</p>
<p>field_size = (20,20)
field = mbs.field2D_bspline(cms,field_size,
degree=(3,3),dim_stack=2).unsqueeze(0)</p>
<h1 id="field_diff-vect_spline_diffeocmsfield_size">field_diff = vect_spline_diffeo(cms,field_size)</h1>
<p>H,W = field_size
xx, yy = torch.meshgrid(torch.linspace(-1, 1, H), torch.linspace(-1, 1, W))</p>
<p>div = field_2d_divergence(field)</p>
<h1 id="_d_ax-pltsubplots">_,d_ax = plt.subplots()</h1>
<p>fig,ax = plt.subplots()</p>
<p>div_plot = ax.imshow(div[0,0,:,:],origin='lower')
ax.quiver(field[0,:,:,0],field[0,:,:,1])
fig.colorbar(div_plot)
plt.show()</p></div>
</dd>
<dt id="demeter.utils.torchbox.find_binary_center"><code class="name flex">
<span>def <span class="ident">find_binary_center</span></span>(<span>bool_img)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.format_sigmas"><code class="name flex">
<span>def <span class="ident">format_sigmas</span></span>(<span>sigmas, dim)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.geodesic_3d_slider"><code class="name flex">
<span>def <span class="ident">geodesic_3d_slider</span></span>(<span>mr)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a 3d image</p>
<p>exemple:
mr = mt.load_optimize_geodesicShooting('2D_13_10_2021_m0t_m1_001.pk1')
geodesic_3d_slider(mr)</p></div>
</dd>
<dt id="demeter.utils.torchbox.get_sobel_kernel_2d"><code class="name flex">
<span>def <span class="ident">get_sobel_kernel_2d</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.get_sobel_kernel_3d"><code class="name flex">
<span>def <span class="ident">get_sobel_kernel_3d</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.grid2im"><code class="name flex">
<span>def <span class="ident">grid2im</span></span>(<span>grid)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape a grid tensor into an image tensor
2D
[T,H,W,2] -&gt; [T,2,H,W]
3D
[T,D,H,W,3] -&gt; [T,3,D,H,W]</p>
<pre><code># grid to image
T,D,H,W = (4,5,6,7)

grid_2D = torch.rand((T,H,W,2))
grid_3D = torch.rand((T,D,H,W,3))

image_2D = torch.rand((T,2,H,W))
image_3D = torch.rand((T,3,D,H,W))

grid_2D_as_image = grid2im(grid_2D)
grid_3D_as_image = grid2im(grid_3D)

# check if the method works
print('
</code></pre>
<p>GRID TO IMAGE')
print(' ==== 2D ====
')
print('grid_2D.shape =',grid_2D.shape)
print('grid_2D_as_image.shape =',grid_2D_as_image.shape)
print('we have indeed the good shape')
count = 0
for i in range(T):
count += (grid_2D[i,&hellip;,0] == grid_2D_as_image[i,0,&hellip;]).sum()
count += (grid_2D[i,&hellip;,1] == grid_2D_as_image[i,1,&hellip;]).sum()</p>
<pre><code>print('count is equal to ',count/(T*H*W*2),'and should be equal to 1')

print('
</code></pre>
<p>==== 3D ====
')
print('grid_3D.shape =',grid_3D.shape)
print('grid_3D_as_image.shape =',grid_3D_as_image.shape)
print('we have indeed the good shape')
count = 0
for i in range(T):
count += (grid_3D[i,&hellip;,0] == grid_3D_as_image[i,0,&hellip;]).sum()
count += (grid_3D[i,&hellip;,1] == grid_3D_as_image[i,1,&hellip;]).sum()
count += (grid_3D[i,&hellip;,2] == grid_3D_as_image[i,2,&hellip;]).sum()</p>
<pre><code>print('count is equal to ',count/(T*H*W*D*3),'and should be equal to 1')
</code></pre></div>
</dd>
<dt id="demeter.utils.torchbox.gridDef_plot"><code class="name flex">
<span>def <span class="ident">gridDef_plot</span></span>(<span>defomation, ax=None, step=2, add_grid=False, check_diffeo=False, title='', color=None, dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.gridDef_plot_2d"><code class="name flex">
<span>def <span class="ident">gridDef_plot_2d</span></span>(<span>deformation, ax=None, step=2, add_grid=False, check_diffeo=False, dx_convention='pixel', title='', color=None, linewidth=None, origin='lower')</span>
</code></dt>
<dd>
<div class="desc"><p>:param field: field to represent
:param grid:
:param saxes[1]:
:param title:
:return:</p></div>
</dd>
<dt id="demeter.utils.torchbox.im2grid"><code class="name flex">
<span>def <span class="ident">im2grid</span></span>(<span>image)</span>
</code></dt>
<dd>
<div class="desc"><p>Reshape an image tensor into a grid tensor
2D case [T,2,H,W]
-&gt;
[T,H,W,2]
3D case [T,3,D,H,W] -&gt;
[T,D,H,W,3]</p>
<pre><code>T,D,H,W = (4,5,6,7)

grid_2D = torch.rand((T,H,W,2))
grid_3D = torch.rand((T,D,H,W,3))

image_2D = torch.rand((T,2,H,W))
image_3D = torch.rand((T,3,D,H,W))

# image to grid
image_2D_as_grid = im2grid(image_2D)
image_3D_as_grid = im2grid(image_3D)

print('
</code></pre>
<p>IMAGE TO GRID')
print(' ==== 2D ====
')
print('image_2D.shape = ',image_2D.shape)
print('image_2D_as_grid.shape = ',image_2D_as_grid.shape)</p>
<pre><code>count = 0
for i in range(T):
    count += (image_2D[i,0,...] == image_2D_as_grid[i,...,0]).sum()
    count += (image_2D[i,1,...] == image_2D_as_grid[i,...,1]).sum()
print('count is equal to ',count/(T*H*W*2),'and should be equal to 1')

print(' ==== 3D ====
</code></pre>
<p>')
print('image_3D.shape = ',image_3D.shape)
print('image_3D_as_grid.shape = ',image_3D_as_grid.shape)</p>
<pre><code>count = 0
for i in range(T):
    count += (image_3D[i,0,...] == image_3D_as_grid[i,...,0]).sum()
    count += (image_3D[i,1,...] == image_3D_as_grid[i,...,1]).sum()
    count += (image_3D[i,2,...] == image_3D_as_grid[i,...,2]).sum()
print('count is equal to ',count/(T*H*W*D*3.0),'and should be equal to 1')
</code></pre></div>
</dd>
<dt id="demeter.utils.torchbox.imCmp"><code class="name flex">
<span>def <span class="ident">imCmp</span></span>(<span>I1, I2, method=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.image_slice"><code class="name flex">
<span>def <span class="ident">image_slice</span></span>(<span>I, coord, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a slice of the image I at the given coordinate and dimension</p>
<p>:param I: [H,W,D] numpy array or tensor
:param coord: int coordinate of the slice, if float it will be casted to int
:param dim: int in {0,1,2} dimension of the slice</p></div>
</dd>
<dt id="demeter.utils.torchbox.imgDeform"><code class="name flex">
<span>def <span class="ident">imgDeform</span></span>(<span>I, field, dx_convention='2square', clamp=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.is_tensor"><code class="name flex">
<span>def <span class="ident">is_tensor</span></span>(<span>input)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.leviCivita_2Dderivative"><code class="name flex">
<span>def <span class="ident">leviCivita_2Dderivative</span></span>(<span>v, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the operation $
abla_w v$</p></div>
</dd>
<dt id="demeter.utils.torchbox.lieBracket"><code class="name flex">
<span>def <span class="ident">lieBracket</span></span>(<span>v, w)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.make_3d_flat"><code class="name flex">
<span>def <span class="ident">make_3d_flat</span></span>(<span>img_3D, slice)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.make_ball_at_shape_center"><code class="name flex">
<span>def <span class="ident">make_ball_at_shape_center</span></span>(<span>img, shape_value=None, overlap_threshold=0.1, r_min=None, force_r=None, force_center=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>:param img:
:param shape_value:
:param overlap_threshold:
:param r_min:
:param verbose:
:return:</p></div>
</dd>
<dt id="demeter.utils.torchbox.make_regular_grid"><code class="name flex">
<span>def <span class="ident">make_regular_grid</span></span>(<span>deformation_shape, device=device(type='cpu'), dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>API for create_meshgrid, it is the identity deformation</p>
<p>:param deformation_shape: tuple such as
(H,W) or (n,H,W,2) for 2D grid
(D,H,W) or (n,D,H,W,3) for 3D grid
:param device: device for selecting cpu or cuda usage
:return: will return 2D identity deformation with size (1,H,W,2) or
3D identity deformation with size (1,D,H,W,3)</p></div>
</dd>
<dt id="demeter.utils.torchbox.nib_normalize"><code class="name flex">
<span>def <span class="ident">nib_normalize</span></span>(<span>img, method='mean')</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.open_nib"><code class="name flex">
<span>def <span class="ident">open_nib</span></span>(<span>folder_name, irm_type, data_base, format='.nii.gz', normalize=True, to_torch=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.open_template_icbm152"><code class="name flex">
<span>def <span class="ident">open_template_icbm152</span></span>(<span>ponderation='t1', normalize=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.pad_to_same_size"><code class="name flex">
<span>def <span class="ident">pad_to_same_size</span></span>(<span>img_1, img_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad the two images in order to make images of the same size
takes</p>
<p>:param img_1: [T_1,C,D_1,H_1,W_1] or [D_1,H_1,W_1]
torch tensor
:param img_2: [T_2,C,D_2,H_2,W_2] or [D_2,H_2,W_2]
torch tensor
:return: will return both images with of shape
[&hellip;,max(D_1,D_2),max(H_1,H_2),max(W_1,W_2)] in a tuple.</p></div>
</dd>
<dt id="demeter.utils.torchbox.pixel2square_convention"><code class="name flex">
<span>def <span class="ident">pixel2square_convention</span></span>(<span>field, grid=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a field in spacial pixelic convention in one on as
[-1,1]^2 square as requested by pytorch's gridSample</p>
<p>:field: (torch tensor) of size [T,H,W,2] or [T,D,H,W,3]
:grid: (bool, default = True) if true field is considered as a deformation (i.e.: field = (id + v))
else field is a vector field (i.e.: field = v)
:return:</p></div>
</dd>
<dt id="demeter.utils.torchbox.quiver_plot"><code class="name flex">
<span>def <span class="ident">quiver_plot</span></span>(<span>field, ax=None, step=2, title='', check_diffeo=False, color=None, dx_convention='pixel', real_scale=True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param field: field to represent
:param grid:
:param saxes[1]:
:param title:
:return:axes</p></div>
</dd>
<dt id="demeter.utils.torchbox.reg_open"><code class="name flex">
<span>def <span class="ident">reg_open</span></span>(<span>number, size=None, requires_grad=False, location='local', device='cpu')</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.resize_image"><code class="name flex">
<span>def <span class="ident">resize_image</span></span>(<span>image, scale_factor)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.showDef"><code class="name flex">
<span>def <span class="ident">showDef</span></span>(<span>field, axes=None, grid=None, step=2, title='', check_diffeo=False, color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.spacialGradient"><code class="name flex">
<span>def <span class="ident">spacialGradient</span></span>(<span>image, dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.spacialGradient_2d"><code class="name flex">
<span>def <span class="ident">spacialGradient_2d</span></span>(<span>image, dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the spatial gradient on 2d images by applying
a sobel kernel</p>
<p>:param image: Tensor [B,C,H,W]
:param dx_convention:
:return: [B,C,2,H,W]</p></div>
</dd>
<dt id="demeter.utils.torchbox.spacialGradient_3d"><code class="name flex">
<span>def <span class="ident">spacialGradient_3d</span></span>(<span>image, dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>:param image: Tensor [B,1,D,H,W]
:param dx_convention:
:return: Tensor [B,C,3,D,H,W]</p>
<p>:Example:
H,W,D = (50,75,100)
image = torch.zeros((H,W,D))
mX,mY,mZ = torch.meshgrid(torch.arange(H),
torch.arange(W),
torch.arange(D))</p>
<p>mask_rond = ((mX - H//2)<strong>2 + (mY - W//2)</strong>2).sqrt() &lt; H//4
mask_carre = (mX &gt; H//4) &amp; (mX &lt; 3<em>H//4) &amp; (mZ &gt; D//4) &amp; (mZ &lt; 3</em>D//4)
mask_diamand = ((mY - W//2).abs() + (mZ - D//2).abs()) &lt; W//4
mask = mask_rond &amp; mask_carre &amp; mask_diamand
image[mask] = 1</p>
<p>grad_image = spacialGradient_3d(image[None,None])</p>
<h1 id="grad_image_sum-grad_imageabssumdim1">grad_image_sum = grad_image.abs().sum(dim=1)</h1>
<h1 id="iv3dimshow_3d_slidergrad_image_sum0">iv3d.imshow_3d_slider(grad_image_sum[0])</h1></div>
</dd>
<dt id="demeter.utils.torchbox.square2pixel_convention"><code class="name flex">
<span>def <span class="ident">square2pixel_convention</span></span>(<span>field, grid=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a field on a square centred and from -1 to 1 convention
as requested by pytorch's gridSample to one in pixelic convention</p>
<p>:return:</p></div>
</dd>
<dt id="demeter.utils.torchbox.thresholding"><code class="name flex">
<span>def <span class="ident">thresholding</span></span>(<span>image, bounds=(0, 1))</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.vectField_show"><code class="name flex">
<span>def <span class="ident">vectField_show</span></span>(<span>field, step=2, check_diffeo=False, title='', dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>:param field: (1,H,W,2) tensor object
:param step:
:param check_diffeo: (bool)
:return:</p>
<p>Example :
cms = mbs.getCMS_allcombinaision()</p>
<p>H,W = 100,150</p>
<h1 id="vector-defomation-generation">vector defomation generation</h1>
<p>v = mbs.field2D_bspline(cms,(H,W),dim_stack=2).unsqueeze(0)
v *= 0.5</p>
<p>vectField_show(v,step=4,check_diffeo=True)</p></div>
</dd>
<dt id="demeter.utils.torchbox.vect_spline_diffeo"><code class="name flex">
<span>def <span class="ident">vect_spline_diffeo</span></span>(<span>control_matrix, field_size, N=None, forward=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="demeter.utils.torchbox.Field_divergence"><code class="flex name class">
<span>class <span class="ident">Field_divergence</span></span>
<span>(</span><span>dx_convention='pixel')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>
<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As per the example above, an <code>__init__()</code> call to the parent class
must be made before assignment on the child.</p>
</div>
<p>:ivar training: Boolean represents whether this module is in training or
evaluation mode.
:vartype training: bool</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field_divergence(torch.nn.Module):

    def __init__(self,dx_convention=&#39;pixel&#39;):
        self.dx_convention = dx_convention

        super(Field_divergence, self).__init__()

    def __repr__(self):
        return (
            self.__class__.__name__
            +&#39;(field dimension =&#39;
            +self.field_dim+&#39;d, &#39;
            +&#39;dx_convention =&#39;
            +self.dx_convention
            +&#39;)&#39;
        )

    def forward(self,field):
        field_as_im = grid2im(field)
        if field.shape[-1] == 2:
            x_sobel = get_sobel_kernel_2d().to(field.device)/8

            field_x_dx = filter2d(field_as_im[:,0,:,:].unsqueeze(1),
                          x_sobel.unsqueeze(0))# * (2/(H-1)))
            field_y_dy = filter2d(field_as_im[:,1,:,:].unsqueeze(1),
                          x_sobel.T.unsqueeze(0))# * (2/(W-1)))

            field_div = torch.stack([field_x_dx, field_y_dy],dim=0)

        elif field.shape[-1] == 3:
            x_sobel = get_sobel_kernel_3d().to(field.device)

            field_x_dx = filter3d(field_as_im[:,0].unsqueeze(1),
                                  x_sobel[0]/x_sobel[0].abs().sum())
            field_y_dy = filter3d(field_as_im[:,1].unsqueeze(1),
                                  x_sobel[1]/x_sobel[1].abs().sum()) # TODO : might be a kind of transposition of the thing
            field_z_dz = filter3d(field_as_im[:,2].unsqueeze(1),
                                  x_sobel[2]/x_sobel[2].abs().sum())
            field_div = torch.stack([field_x_dx, field_y_dy, field_z_dz],dim=0)

        if self.dx_convention == &#39;2square&#39;:
            return torch.stack(
                [(s-1)/2*field_div[i] for i,s in enumerate(field_as_im.shape[2:])],
                dim=0).sum(dim=0)
        else:
            return field_div.sum(dim=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="demeter.utils.torchbox.Field_divergence.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, field) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="demeter.utils.torchbox.parse_brats"><code class="flex name class">
<span>class <span class="ident">parse_brats</span></span>
<span>(</span><span>brats_list=None, template_folder=None, brats_folder=None, get_template=True, modality='T1', device='cpu')</span>
</code></dt>
<dd>
<div class="desc"><p>:param brats_list: list of stings containing the name of the folders
:param template_folder: path to template folder
:param brats_folder: path to brats db
:param modality: modality of the IRM ex: <code>'T1'</code>,<code>'T2'</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parse_brats:

    def __init__(self,brats_list=None,
                 template_folder=None,
                 brats_folder=None,
                 get_template=True,
                 modality=&#39;T1&#39;,
                 device = &#39;cpu&#39;):
        &#34;&#34;&#34;

        :param brats_list: list of stings containing the name of the folders
        :param template_folder: path to template folder
        :param brats_folder: path to brats db
        :param modality: modality of the IRM ex: `&#39;T1&#39;`,`&#39;T2&#39;`
        &#34;&#34;&#34;
        self.flag_brats_2021 = False
        self.flag_bratsReg_2022 = False
        if template_folder is None:
            template_folder = ROOT_DIRECTORY+&#39;/../data/template/sri_spm8/templates/&#39;
        if brats_folder is None or &#39;2021&#39; in brats_folder:
            self.brats_folder = ROOT_DIRECTORY+&#39;/../data/brats_2021/&#39;
            self.flag_brats_2021 = True
        elif &#34;2022_valid&#34; in brats_folder:
            self.brats_folder = ROOT_DIRECTORY+&#39;/../data/bratsreg_2022/BraTSReg_Validation_Data/&#39;
            self.flag_bratsReg_2022 = True
        elif &#34;2022&#34; in brats_folder:
            self.brats_folder = ROOT_DIRECTORY+&#39;/../data/bratsreg_2022/BraTSReg_Training_Data_v3/&#39;
            # print(f&#34;\n!!!!!! {self.flag_bratsReg_2022} &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&#34;)
            self.flag_bratsReg_2022 = True


        # TODO : check that the list is correct by parsing with os.get_dir ...
        if brats_list is None:
            if self.flag_brats_2021:
                warnings.warn(&#34;It is not recommended to set brats_list to None with BraTS2021&#34;
                              &#34;database. It can lead to errors because ventricule segmentations &#34;
                              &#34;where not made for all data.&#34;)
            self._make_brats_list(self.brats_folder)
        else:
            self.brats_list = brats_list
        self.modality = modality
        self.device = device
        self.flag_get_template = get_template
        if not self.flag_bratsReg_2022 and get_template:
            template_nib = nib_load(template_folder+modality+&#34;_brain.nii&#34;)
            self.template_affine = template_nib.affine
            self.template_img = template_nib.get_fdata()[:,::-1,:,0]

            self.template_seg = nib_load(template_folder+&#39;seg_sri24.mgz&#39;).get_fdata()


    def _make_brats_list(self,folder):
        self.brats_list = []
        for obj in os.listdir(folder):
            if self.flag_bratsReg_2022 and &#39;BraTSReg_&#39; in obj:
                self.brats_list.append(obj)
            if self.flag_brats_2021 and &#39;BraTS2021&#39; in obj:
                self.brats_list.append(obj)

    def get_template(self,normalised=True):
        if normalised:
            img_norm = (self.template_img - self.template_img.min()) / (self.template_img.max() - self.template_img.min())
            return torch.Tensor(img_norm,device=self.device)[None,None]
        else:
            return torch.Tensor(self.template_img.copy(),device=self.device)

    def get_template_vesi(self):
        vesi_seg = torch.zeros(self.template_seg.shape)
        vesi_seg[self.template_seg==4] = 1
        vesi_seg[self.template_seg==43] = 1
        return vesi_seg.flip(1)

    def get_template_whiteMatter(self):
        whmtr_seg = torch.zeros(self.template_seg.shape)
        whmtr_seg[self.template_seg==2] = 1
        whmtr_seg[self.template_seg==41] = 1
        return whmtr_seg.flip(1)

    def get_vesicule_seg(self,index,mask_correction=None):
        path = ROOT_DIRECTORY+ &#39;/../data/brats_2021/&#39;
        brats_name = self.brats_list[index]
        brats_img_size = (240,240,155)
        vesi,header = nrrd.read(path+brats_name+&#39;/&#39;+brats_name+&#39;_segV.seg.nrrd&#39;)
        space_origin = header[&#39;space origin&#39;]
        vesi_s = vesi.shape
        if vesi_s == brats_img_size: return torch.tensor( vesi)[None,None]

        vesi_pad = np.zeros(brats_img_size)
        vesi_pad[
        int(space_origin[0]):int(space_origin[0]+vesi_s[0]),
        int(space_origin[1]):int(space_origin[1]+vesi_s[1]),
        int(space_origin[2]):int(space_origin[2]+vesi_s[2])
        ] = vesi
        # vesi = open_nib(brats_name,&#39;segV&#39;,&#39;brats_2021&#39;,
        #                   format=&#39;.nii.gz&#39;,normalize=False,to_torch=True)
        # img_1 = torch.zeros(vesi.shape)
        # img_1[vesi==4] = 1
        # img_1[vesi==43] = 1
        if not mask_correction is None:
            vesi[mask_correction&gt;0] =0
        return torch.tensor( vesi_pad)[None,None]

    def _read_landmarks_csv_(self,file):
        with open(file) as csv_f:
            csv_reader = csv.DictReader(csv_f,delimiter=&#39;,&#39;)
            landmarks = []
            for row in csv_reader:
                try:
                    listv = [
                        float(row[&#34;Z&#34;]),
                        239 + float(row[&#34;Y&#34;]),
                        float(row[&#34;X&#34;])
                    ]
                except KeyError:
                    listv = [
                        float(row[&#34; Z&#34;]),
                        239 + float(row[&#34; Y&#34;]),
                        float(row[&#34; X&#34;])
                    ]
                landmarks.append(listv)
        return torch.Tensor(landmarks)

    def _get_landmarks(self,path,file_list):
        file_ldk_1 = [f for f in file_list if &#39;_01_&#39; in f and &#39;_landmarks.csv&#39; in f][0]
        # print(file_ldk_1)
        ldk_1 = self._read_landmarks_csv_(path+file_ldk_1)
        if &#39;Training_Data&#39; in path:
            file_ldk_0 = [f for f in file_list if &#39;_00_&#39; in f and &#39;_landmarks.csv&#39; in f][0]
            # print(file_ldk_0)
            ldk_0 = self._read_landmarks_csv_(path+file_ldk_0)
            return (ldk_0,ldk_1)
        return (None,ldk_1)

    def _call_brats_2021_(self,index,to_torch,normalize=False):
        brats_name = self.brats_list[index]
        print(&#34;mean&#34;)
        gliom = open_nib(brats_name,self.modality.lower(),&#39;brats_2021&#39;,normalize=&#39;min_max&#39;,to_torch=False)
        segmentation_tumor = open_nib(brats_name,&#39;seg&#39;,&#39;brats_2021&#39;,normalize=False,to_torch=to_torch)
        if to_torch:
            segmentation_tumor[segmentation_tumor== 2] = .5
            segmentation_tumor[segmentation_tumor == 4] = 1
        else: segmentation_tumor = segmentation_tumor.get_fdata()
        # gliom = nib.load(&#34;/Users/maillard/Downloads/RSNA_ASNR_MICCAI_BraTS2021_TrainingData_16July2021/BraTS2021_00008/BraTS2021_000_T1.nii.gz&#34;)
        # histogram normalisation
        gliom_img = gliom.get_fdata()
        if self.flag_get_template and normalize:
            gliom_img[gliom_img &gt; 0] = match_histograms(gliom_img[gliom_img &gt; 0], self.template_img[self.template_img &gt; 0])
            gliom_img = (gliom_img - gliom_img.min()) / (gliom_img.max() - gliom_img.min())

        if to_torch:
            gliom_img = torch.Tensor(gliom_img,device=self.device)[None,None]
        return (gliom_img,
                segmentation_tumor)

    def _call_bratsReg_2022(self,index,to_torch,scale=0,rigidly_reg = False):
        &#34;&#34;&#34;

        :param index: (int)
        :return: The two brains data to get.
        !!! Do not use rigidly_reg it does not work
        &#34;&#34;&#34;
        path = self.brats_folder


        folder_name = self.brats_list[index]
        path += folder_name+&#39;/&#39;
        file_list = os.listdir(path)
        file_0 = [f for f in file_list if &#39;_00_&#39; in f  and self.modality.lower()+&#39;.&#39; in f][0]
        if rigidly_reg:
            file_1 = [
                f for f in file_list
                if &#39;_01_&#39; in f and self.modality.lower() in f and &#39;resampled&#39; in f ][0]
        else:
            file_1 = [f for f in file_list if &#39;_01_&#39; in f  and self.modality.lower()+&#39;.&#39; in f][0]
        #print(file_0,file_1)
        img_nib_0 = nib_load(path + file_0)
        self.affine = img_nib_0.affine
        img_0 = img_nib_0.get_fdata()

        img_nib_1 = nib_load(path + file_1)
        img_1 = img_nib_1.get_fdata()

        # img_1[img_1 &gt; 0] = match_histograms(img_1[img_1 &gt; 0], img_0[img_0 &gt; 0])
        img_0 = (img_0 - img_0.min()) / (img_0.max() - img_0.min())
        img_1 = (img_1 - img_1.min()) / (img_1.max() - img_1.min())
        # v_min, v_max = min(img_0.min(), img_1.min()), max(img_0.max(),img_1.max() )
        # v_min, v_max = img_0.min(),img_0.max()
        #
        # img_0 = (img_0 - v_min) / (v_max - v_min)
        # img_1 = (img_1 - v_min) / (v_max - v_min)



        landmarks = self._get_landmarks(path,file_list)

        # Segmentation !
        if &#39;Training_Data&#39; in path:
            seg_path = ROOT_DIRECTORY+&#34;/../data/bratsreg_2022/Train_seg/&#34;
        elif &#39;Validation&#39; in path:
            seg_path = ROOT_DIRECTORY+&#34;/../data/bratsreg_2022/Valid_seg/&#34;
        else:
            raise ValueError(&#34;Something went wrong.&#34;)
        seg_img_0 = nib_load(seg_path+folder_name+&#39;_seg_00_.nii.gz&#39;).get_fdata()
        seg_img_0[seg_img_0 == 1] = 3
        seg_img_0[seg_img_0 == 2] = 1.5
        seg_img_0 = seg_img_0/3

        seg_img_1 = nib_load(seg_path+folder_name+&#39;_seg_01_.nii.gz&#39;).get_fdata()
        seg_img_1[seg_img_1 == 1] = 3
        seg_img_1[seg_img_1 == 2] = 1.5
        seg_img_1 = seg_img_1/3

        # TODO : Check if we should normalize
        if to_torch:
            img_0 = torch.Tensor(img_0,device=self.device)[None,None]
            img_1 = torch.Tensor(img_1,device=self.device)[None,None]

            seg_img_0 =torch.Tensor(seg_img_0,device=self.device)[None,None]
            seg_img_1 =torch.Tensor(seg_img_1,device=self.device)[None,None]
            if scale != 1:
                img_0,img_1,seg_img_0,seg_img_1 = resize_image((img_0,img_1,seg_img_0,seg_img_1),scale)
                landmarks = (
                    landmarks[0]*scale if not landmarks[0] is None else None,
                    landmarks[1]*scale
                )

        return img_0,img_1,seg_img_0,seg_img_1,landmarks

    def __call__(self, index,
                 to_torch = True,
                 modality = None,
                 scale=0,
                 rigidly_reg=False,
                 normalize=False):
        &#34;&#34;&#34; Open the brats folder in self.brats_list at the desired index

        :param index: must be int &lt; len(brats_list)
        :param to_torch: (bool) return image as torch.Tensor if True, else a numpy array.
        :return: image at the index of the brats_list
        &#34;&#34;&#34;
        if index &gt;= len(self.brats_list):
            raise ValueError(f&#34;You asked for a too high value, index is : {index} and len(brat_list) is : {len(self.brats_list)}&#34;)
        if not modality is None:
            self.modality = modality
        if self.flag_brats_2021:
            return self._call_brats_2021_(index,to_torch,normalize=normalize)
        if self.flag_bratsReg_2022:
            return self._call_bratsReg_2022(index,to_torch,scale,rigidly_reg=rigidly_reg)
        # source = nib.Nifti1Image(source_img, self.template_affine)
        # return source.get_fdata()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="demeter.utils.torchbox.parse_brats.get_template"><code class="name flex">
<span>def <span class="ident">get_template</span></span>(<span>self, normalised=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.parse_brats.get_template_vesi"><code class="name flex">
<span>def <span class="ident">get_template_vesi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.parse_brats.get_template_whiteMatter"><code class="name flex">
<span>def <span class="ident">get_template_whiteMatter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demeter.utils.torchbox.parse_brats.get_vesicule_seg"><code class="name flex">
<span>def <span class="ident">get_vesicule_seg</span></span>(<span>self, index, mask_correction=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="demeter.utils" href="index.html">demeter.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="demeter.utils.torchbox.BCH" href="#demeter.utils.torchbox.BCH">BCH</a></code></li>
<li><code><a title="demeter.utils.torchbox.addGrid2im" href="#demeter.utils.torchbox.addGrid2im">addGrid2im</a></code></li>
<li><code><a title="demeter.utils.torchbox.checkDiffeo" href="#demeter.utils.torchbox.checkDiffeo">checkDiffeo</a></code></li>
<li><code><a title="demeter.utils.torchbox.compose_fields" href="#demeter.utils.torchbox.compose_fields">compose_fields</a></code></li>
<li><code><a title="demeter.utils.torchbox.create_meshgrid3d" href="#demeter.utils.torchbox.create_meshgrid3d">create_meshgrid3d</a></code></li>
<li><code><a title="demeter.utils.torchbox.deformation_show" href="#demeter.utils.torchbox.deformation_show">deformation_show</a></code></li>
<li><code><a title="demeter.utils.torchbox.detOfJacobian" href="#demeter.utils.torchbox.detOfJacobian">detOfJacobian</a></code></li>
<li><code><a title="demeter.utils.torchbox.field2diffeo" href="#demeter.utils.torchbox.field2diffeo">field2diffeo</a></code></li>
<li><code><a title="demeter.utils.torchbox.fieldNorm2" href="#demeter.utils.torchbox.fieldNorm2">fieldNorm2</a></code></li>
<li><code><a title="demeter.utils.torchbox.field_2d_hessian" href="#demeter.utils.torchbox.field_2d_hessian">field_2d_hessian</a></code></li>
<li><code><a title="demeter.utils.torchbox.field_2d_jacobian" href="#demeter.utils.torchbox.field_2d_jacobian">field_2d_jacobian</a></code></li>
<li><code><a title="demeter.utils.torchbox.field_divergence" href="#demeter.utils.torchbox.field_divergence">field_divergence</a></code></li>
<li><code><a title="demeter.utils.torchbox.find_binary_center" href="#demeter.utils.torchbox.find_binary_center">find_binary_center</a></code></li>
<li><code><a title="demeter.utils.torchbox.format_sigmas" href="#demeter.utils.torchbox.format_sigmas">format_sigmas</a></code></li>
<li><code><a title="demeter.utils.torchbox.geodesic_3d_slider" href="#demeter.utils.torchbox.geodesic_3d_slider">geodesic_3d_slider</a></code></li>
<li><code><a title="demeter.utils.torchbox.get_sobel_kernel_2d" href="#demeter.utils.torchbox.get_sobel_kernel_2d">get_sobel_kernel_2d</a></code></li>
<li><code><a title="demeter.utils.torchbox.get_sobel_kernel_3d" href="#demeter.utils.torchbox.get_sobel_kernel_3d">get_sobel_kernel_3d</a></code></li>
<li><code><a title="demeter.utils.torchbox.grid2im" href="#demeter.utils.torchbox.grid2im">grid2im</a></code></li>
<li><code><a title="demeter.utils.torchbox.gridDef_plot" href="#demeter.utils.torchbox.gridDef_plot">gridDef_plot</a></code></li>
<li><code><a title="demeter.utils.torchbox.gridDef_plot_2d" href="#demeter.utils.torchbox.gridDef_plot_2d">gridDef_plot_2d</a></code></li>
<li><code><a title="demeter.utils.torchbox.im2grid" href="#demeter.utils.torchbox.im2grid">im2grid</a></code></li>
<li><code><a title="demeter.utils.torchbox.imCmp" href="#demeter.utils.torchbox.imCmp">imCmp</a></code></li>
<li><code><a title="demeter.utils.torchbox.image_slice" href="#demeter.utils.torchbox.image_slice">image_slice</a></code></li>
<li><code><a title="demeter.utils.torchbox.imgDeform" href="#demeter.utils.torchbox.imgDeform">imgDeform</a></code></li>
<li><code><a title="demeter.utils.torchbox.is_tensor" href="#demeter.utils.torchbox.is_tensor">is_tensor</a></code></li>
<li><code><a title="demeter.utils.torchbox.leviCivita_2Dderivative" href="#demeter.utils.torchbox.leviCivita_2Dderivative">leviCivita_2Dderivative</a></code></li>
<li><code><a title="demeter.utils.torchbox.lieBracket" href="#demeter.utils.torchbox.lieBracket">lieBracket</a></code></li>
<li><code><a title="demeter.utils.torchbox.make_3d_flat" href="#demeter.utils.torchbox.make_3d_flat">make_3d_flat</a></code></li>
<li><code><a title="demeter.utils.torchbox.make_ball_at_shape_center" href="#demeter.utils.torchbox.make_ball_at_shape_center">make_ball_at_shape_center</a></code></li>
<li><code><a title="demeter.utils.torchbox.make_regular_grid" href="#demeter.utils.torchbox.make_regular_grid">make_regular_grid</a></code></li>
<li><code><a title="demeter.utils.torchbox.nib_normalize" href="#demeter.utils.torchbox.nib_normalize">nib_normalize</a></code></li>
<li><code><a title="demeter.utils.torchbox.open_nib" href="#demeter.utils.torchbox.open_nib">open_nib</a></code></li>
<li><code><a title="demeter.utils.torchbox.open_template_icbm152" href="#demeter.utils.torchbox.open_template_icbm152">open_template_icbm152</a></code></li>
<li><code><a title="demeter.utils.torchbox.pad_to_same_size" href="#demeter.utils.torchbox.pad_to_same_size">pad_to_same_size</a></code></li>
<li><code><a title="demeter.utils.torchbox.pixel2square_convention" href="#demeter.utils.torchbox.pixel2square_convention">pixel2square_convention</a></code></li>
<li><code><a title="demeter.utils.torchbox.quiver_plot" href="#demeter.utils.torchbox.quiver_plot">quiver_plot</a></code></li>
<li><code><a title="demeter.utils.torchbox.reg_open" href="#demeter.utils.torchbox.reg_open">reg_open</a></code></li>
<li><code><a title="demeter.utils.torchbox.resize_image" href="#demeter.utils.torchbox.resize_image">resize_image</a></code></li>
<li><code><a title="demeter.utils.torchbox.showDef" href="#demeter.utils.torchbox.showDef">showDef</a></code></li>
<li><code><a title="demeter.utils.torchbox.spacialGradient" href="#demeter.utils.torchbox.spacialGradient">spacialGradient</a></code></li>
<li><code><a title="demeter.utils.torchbox.spacialGradient_2d" href="#demeter.utils.torchbox.spacialGradient_2d">spacialGradient_2d</a></code></li>
<li><code><a title="demeter.utils.torchbox.spacialGradient_3d" href="#demeter.utils.torchbox.spacialGradient_3d">spacialGradient_3d</a></code></li>
<li><code><a title="demeter.utils.torchbox.square2pixel_convention" href="#demeter.utils.torchbox.square2pixel_convention">square2pixel_convention</a></code></li>
<li><code><a title="demeter.utils.torchbox.thresholding" href="#demeter.utils.torchbox.thresholding">thresholding</a></code></li>
<li><code><a title="demeter.utils.torchbox.vectField_show" href="#demeter.utils.torchbox.vectField_show">vectField_show</a></code></li>
<li><code><a title="demeter.utils.torchbox.vect_spline_diffeo" href="#demeter.utils.torchbox.vect_spline_diffeo">vect_spline_diffeo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="demeter.utils.torchbox.Field_divergence" href="#demeter.utils.torchbox.Field_divergence">Field_divergence</a></code></h4>
<ul class="">
<li><code><a title="demeter.utils.torchbox.Field_divergence.forward" href="#demeter.utils.torchbox.Field_divergence.forward">forward</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demeter.utils.torchbox.parse_brats" href="#demeter.utils.torchbox.parse_brats">parse_brats</a></code></h4>
<ul class="">
<li><code><a title="demeter.utils.torchbox.parse_brats.get_template" href="#demeter.utils.torchbox.parse_brats.get_template">get_template</a></code></li>
<li><code><a title="demeter.utils.torchbox.parse_brats.get_template_vesi" href="#demeter.utils.torchbox.parse_brats.get_template_vesi">get_template_vesi</a></code></li>
<li><code><a title="demeter.utils.torchbox.parse_brats.get_template_whiteMatter" href="#demeter.utils.torchbox.parse_brats.get_template_whiteMatter">get_template_whiteMatter</a></code></li>
<li><code><a title="demeter.utils.torchbox.parse_brats.get_vesicule_seg" href="#demeter.utils.torchbox.parse_brats.get_vesicule_seg">get_vesicule_seg</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
